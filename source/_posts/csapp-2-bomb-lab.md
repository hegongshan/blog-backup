---
title: 《深入理解计算机系统》实验2.Bomb Lab
date: 2021-05-09 22:59:44
tags: CSAPP
categories: CSAPP
mathjax: true
---

Bomb Lab主要考察汇编语言。

<!--more-->

gdb（**G**NU **d**e**b**ugger）用于调试C语言程序，CSAPP提供的参考手册参看[这里](http://csapp.cs.cmu.edu/2e/docs/gdbnotes-x86-64.pdf)。

常用的命令有：

```c
disas // 反汇编当前函数
disas sum // 反汇编函数sum

// ------调试------
// 若调用了其他函数，step/stepi会进入函数内部，而next/nexti不会
stepi // 执行下一条指令
step // 执行下一条语句
nexti // 执行下一条指令
next // 执行下一条语句

print 0x100 // 输出0x100的十进制表示
print /x 555 // 输出555的十六进制表示

print /d $rax // 以十进制输出寄存器%rax中的值
print /x $rax // 以十六进制输出寄存器%rax中的值
print /t $rax // 以二进制输出寄存器%rax中的值

x/s 0xbffff890 //检查地址0xbffff890中存储的字符串
```

下面，开始实验：

```c
gdb bomb
```

按下`Ctrl+X+A`可以进入GDB的文本用户界面tui（Text User Interface），默认显示的是源代码。

本实验考查的是汇编语言，因此，使用命令`layout asm`查看汇编代码。

### 阶段一

```c
/* Hmm...  Six phases must be more secure than one phase! */
input = read_line();             /* Get input                   */
phase_1(input);                  /* Run the phase               */
phase_defused();                 /* Drat!  They figured it out!
			      * Let me know how they did it. */
printf("Phase 1 defused. How about the next one?\n");
```

函数phase_1的汇编代码如下：

```assembly
(gdb) disas phase_1
Dump of assembler code for function phase_1:
   0x0000000000400ee0 <+0>:	sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:	mov    $0x402400,%esi
   0x0000000000400ee9 <+9>:	call   0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:	test   %eax,%eax
   0x0000000000400ef0 <+16>:	je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:	call   0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:	add    $0x8,%rsp
   0x0000000000400efb <+27>:	ret    
End of assembler dump.
```

其中，核心代码为第<+4>~<+16>行。

`mov    $0x402400,%esi`：将地址0x402400中的值复制到寄存器%esi（用于存储函数调用时的第二个参数）中。

`call   0x401338 <strings_not_equal>`：判断输入的字符串input（存储在寄存器%edi中）和%esi中存储的字符串是否相等；

`test   %eax,%eax`：测试%eax & %eax（寄存器%eax用于存储函数调用的返回值）；

`je     0x400ef7 <phase_1+23>`：当test的结果为0（即%eax中的值为0）时，跳转到0x400ef7 <phase_1+23>；否则，调用函数explode_bomb；

为了跳过函数explode_bomb，必须保证输入的字符串input与地址0x402400中的字符串相等。因此，需要输入的字符串必须为：

```assembly
(gdb) x/s 0x402400
0x402400:	"Border relations with Canada have never been better."
```

### 阶段二

```assembly
(gdb) disas phase_2
Dump of assembler code for function phase_2:
   0x0000000000400efc <+0>:	push   %rbp
   0x0000000000400efd <+1>:	push   %rbx
   0x0000000000400efe <+2>:	sub    $0x28,%rsp
   ----------------------------1-------------------------------
   0x0000000000400f02 <+6>:	mov    %rsp,%rsi
   0x0000000000400f05 <+9>:	call   0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:	cmpl   $0x1,(%rsp)
   0x0000000000400f0e <+18>:	je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:	call   0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:	jmp    0x400f30 <phase_2+52>
   ----------------------------2-------------------------------
   0x0000000000400f17 <+27>:	mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:	add    %eax,%eax
   0x0000000000400f1c <+32>:	cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:	je     0x400f25 <phase_2+41>
   ----------------------------3-------------------------------
   0x0000000000400f20 <+36>:	call   0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:	add    $0x4,%rbx
   0x0000000000400f29 <+45>:	cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:	jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:	jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:	lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:	lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:	jmp    0x400f17 <phase_2+27>
   ----------------------------4-------------------------------
   0x0000000000400f3c <+64>:	add    $0x28,%rsp
   0x0000000000400f40 <+68>:	pop    %rbx
   0x0000000000400f41 <+69>:	pop    %rbp
   0x0000000000400f42 <+70>:	ret    
End of assembler dump.
```

<+9>调用了**read_six_numbers**函数，从函数名来看，需要输入六个数字。而<+14>的**cmpl   $0x1,(%rsp)**表明第一个数字必须为1。

```
%rsp | %rsp + 0x4 | %rsp + 0x8 | %rsp + 0xc | %rsp + 0x10 | %rsp + 0x14 | %rbp = %rsp + 0x18 |
```

由<+27>~<+34>可知：**%rbx - 2 %eax == 0**，即当前数字必须等于前一个数字的2倍。

因此，六个数字分别为1、2、4、8、16、32。

接着，再回过头来看下**read_six_numbers**：

```assembly
(gdb) disas read_six_numbers
Dump of assembler code for function read_six_numbers:
   0x000000000040145c <+0>:	sub    $0x18,%rsp
   0x0000000000401460 <+4>:	mov    %rsi,%rdx
   0x0000000000401463 <+7>:	lea    0x4(%rsi),%rcx
   0x0000000000401467 <+11>:	lea    0x14(%rsi),%rax
   0x000000000040146b <+15>:	mov    %rax,0x8(%rsp)
   0x0000000000401470 <+20>:	lea    0x10(%rsi),%rax
   0x0000000000401474 <+24>:	mov    %rax,(%rsp)
   0x0000000000401478 <+28>:	lea    0xc(%rsi),%r9
   0x000000000040147c <+32>:	lea    0x8(%rsi),%r8
   ----------------------------------------------------------------
   0x0000000000401480 <+36>:	mov    $0x4025c3,%esi
   0x0000000000401485 <+41>:	mov    $0x0,%eax
   0x000000000040148a <+46>:	call   0x400bf0 <__isoc99_sscanf@plt>
   ----------------------------------------------------------------
   0x000000000040148f <+51>:	cmp    $0x5,%eax
   0x0000000000401492 <+54>:	jg     0x401499 <read_six_numbers+61>
   0x0000000000401494 <+56>:	call   0x40143a <explode_bomb>
   0x0000000000401499 <+61>:	add    $0x18,%rsp
   0x000000000040149d <+65>:	ret    
End of assembler dump.
```

这里调用了sscanf函数，其第二个参数为输入字符串的格式，对应第13行的**mov    $0x4025c3,%esi**：

```assembly
(gdb) x/s 0x4025c3
0x4025c3:	"%d %d %d %d %d %d"
```

因此，输入的字符串为`1 2 4 8 16 32`。

### 阶段三

```assembly
(gdb) disas phase_3
Dump of assembler code for function phase_3:
   0x0000000000400f43 <+0>:	sub    $0x18,%rsp
   ---------------------------1-------------------------------------
   0x0000000000400f47 <+4>:	lea    0xc(%rsp),%rcx ;第四个参数
   0x0000000000400f4c <+9>:	lea    0x8(%rsp),%rdx ;第三个参数
   0x0000000000400f51 <+14>:	mov    $0x4025cf,%esi
   0x0000000000400f56 <+19>:	mov    $0x0,%eax
   0x0000000000400f5b <+24>:	call   0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000400f60 <+29>:	cmp    $0x1,%eax ;返回值>1
   0x0000000000400f63 <+32>:	jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:	call   0x40143a <explode_bomb>
   ---------------------------2-------------------------------------
   0x0000000000400f6a <+39>:	cmpl   $0x7,0x8(%rsp) ;第三个参数<=7
   0x0000000000400f6f <+44>:	ja     0x400fad <phase_3+106>
   0x0000000000400f71 <+46>:	mov    0x8(%rsp),%eax
   ---------------------------3-------------------------------------
   0x0000000000400f75 <+50>:	jmp    *0x402470(,%rax,8);8 %rax + 0x402470
   0x0000000000400f7c <+57>:	mov    $0xcf,%eax ;第一个数为0时，跳转至此
   0x0000000000400f81 <+62>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:	mov    $0x2c3,%eax ;第一个数为2时，跳转至此
   0x0000000000400f88 <+69>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:	mov    $0x100,%eax ;第一个数为3时，跳转至此
   0x0000000000400f8f <+76>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:	mov    $0x185,%eax ;第一个数为4时，跳转至此
   0x0000000000400f96 <+83>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:	mov    $0xce,%eax ;第一个数为5时，跳转至此
   0x0000000000400f9d <+90>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:	mov    $0x2aa,%eax ;第一个数为6时，跳转至此
   0x0000000000400fa4 <+97>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:	mov    $0x147,%eax ;第一个数为7时，跳转至此
   0x0000000000400fab <+104>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:	call   0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:	mov    $0x0,%eax
   0x0000000000400fb7 <+116>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:	mov    $0x137,%eax ;当第一个数为1时，跳转至此
   ---------------------------4-------------------------------------
   0x0000000000400fbe <+123>:	cmp    0xc(%rsp),%eax ;%eax的值等于输入的第二个数字，共有8个可选值
   0x0000000000400fc2 <+127>:	je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:	call   0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:	add    $0x18,%rsp
   0x0000000000400fcd <+138>:	ret    
End of assembler dump.
```

这里调用了sscanf函数，通过查看<phase_1+14>中的**mov    $0x4025cf,%esi**，可以发现其输入的字符串格式为：

```assembly
(gdb) x/s 0x4025cf
0x4025cf:	"%d %d"
```

也就是说，phase_3需要输入两个数字。根据<phase_3+9>、<phase_3+39>和<phase_3+44>可以得出：**0<=输入的第一个数字<=7**。

在<phase_3+50>中，***0x402470(,%rax,8)**的值为***(8 %rax +  0x402470)**，具体的跳转地址取决于%rax中的值，即输入的第一个数字。

|         地址表达式         | 对应的跳转地址 | 第二个数字（十六进制） | 对应的十进制 |
| :------------------------: | :------------: | :--------------------: | :----------: |
| $*(0x402470 + 0 \times 8)$ |    0x400f7c    |          0xcf          |     207      |
| $*(0x402470 + 1 \times 8)$ |    0x400fb9    |         0x137          |     311      |
| $*(0x402470 + 2 \times 8)$ |    0x400f83    |         0x2c3          |     707      |
| $*(0x402470 + 3 \times 8)$ |    0x400f8a    |         0x100          |     256      |
| $*(0x402470 + 4 \times 8)$ |    0x400f91    |         0x185          |     389      |
| $*(0x402470 + 5 \times 8)$ |    0x400f98    |          0xce          |     206      |
| $*(0x402470 + 6 \times 8)$ |    0x400f9f    |         0x2aa          |     682      |
| $*(0x402470 + 7 \times 8)$ |    0x400fa6    |         0x147          |     327      |

因此，可选的输入字符串为：

```
0 207
1 311
2 707
3 256
4 389
5 206
6 682
7 327
```

### 阶段四

```assembly
(gdb) disas phase_4
Dump of assembler code for function phase_4:
   0x000000000040100c <+0>:	sub    $0x18,%rsp
   ---------------------------1----------------------------
   0x0000000000401010 <+4>:	lea    0xc(%rsp),%rcx
   0x0000000000401015 <+9>:	lea    0x8(%rsp),%rdx
   0x000000000040101a <+14>:	mov    $0x4025cf,%esi
   0x000000000040101f <+19>:	mov    $0x0,%eax
   0x0000000000401024 <+24>:	call   0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000401029 <+29>:	cmp    $0x2,%eax ;输入的数字个数为2
   0x000000000040102c <+32>:	jne    0x401035 <phase_4+41>
   ---------------------------2----------------------------
   0x000000000040102e <+34>:	cmpl   $0xe,0x8(%rsp)
   0x0000000000401033 <+39>:	jbe    0x40103a <phase_4+46> ;第一个数字<=14
   0x0000000000401035 <+41>:	call   0x40143a <explode_bomb>
   0x000000000040103a <+46>:	mov    $0xe,%edx
   0x000000000040103f <+51>:	mov    $0x0,%esi
   0x0000000000401044 <+56>:	mov    0x8(%rsp),%edi
   0x0000000000401048 <+60>:	call   0x400fce <func4>
   0x000000000040104d <+65>:	test   %eax,%eax
   0x000000000040104f <+67>:	jne    0x401058 <phase_4+76> ;func4必须返回0
   0x0000000000401051 <+69>:	cmpl   $0x0,0xc(%rsp) 
   0x0000000000401056 <+74>:	je     0x40105d <phase_4+81> ;第二个数字必须为0
   0x0000000000401058 <+76>:	call   0x40143a <explode_bomb>
   ---------------------------3----------------------------
   0x000000000040105d <+81>:	add    $0x18,%rsp
   0x0000000000401061 <+85>:	ret    
End of assembler dump.
```



```assembly
(gdb) x/s 0x4025cf
0x4025cf:	"%d %d"
```

因此，可以得出如下信息：

1. 需要输入两个数字，格式为"%d %d"
2. 第一个数字<=14，且为函数func4的第一个参数（func4必须返回0）
3. 第二个数字为0

接下来看看函数func4：

```assembly
(gdb) disas func4
Dump of assembler code for function func4:
   0x0000000000400fce <+0>:	sub    $0x8,%rsp
   ---------------------------1----------------------------
   0x0000000000400fd2 <+4>:	mov    %edx,%eax
   0x0000000000400fd4 <+6>:	sub    %esi,%eax
   0x0000000000400fd6 <+8>:	mov    %eax,%ecx
   0x0000000000400fd8 <+10>:	shr    $0x1f,%ecx
   0x0000000000400fdb <+13>:	add    %ecx,%eax
   0x0000000000400fdd <+15>:	sar    %eax
   0x0000000000400fdf <+17>:	lea    (%rax,%rsi,1),%ecx
   ---------------------------2-----------------------------
   0x0000000000400fe2 <+20>:	cmp    %edi,%ecx
   0x0000000000400fe4 <+22>:	jle    0x400ff2 <func4+36>
   0x0000000000400fe6 <+24>:	lea    -0x1(%rcx),%edx
   0x0000000000400fe9 <+27>:	call   0x400fce <func4>
   0x0000000000400fee <+32>:	add    %eax,%eax
   0x0000000000400ff0 <+34>:	jmp    0x401007 <func4+57>
   0x0000000000400ff2 <+36>:	mov    $0x0,%eax
   0x0000000000400ff7 <+41>:	cmp    %edi,%ecx
   0x0000000000400ff9 <+43>:	jge    0x401007 <func4+57>
   0x0000000000400ffb <+45>:	lea    0x1(%rcx),%esi
   0x0000000000400ffe <+48>:	call   0x400fce <func4>
   0x0000000000401003 <+53>:	lea    0x1(%rax,%rax,1),%eax
   ---------------------------3------------------------------
   0x0000000000401007 <+57>:	add    $0x8,%rsp
   0x000000000040100b <+61>:	ret    
End of assembler dump.
```

将上述汇编代码转换为C语言代码，可以得到函数func4：

```c
//b = 0, c = 14, 返回值必须为0
int func4(int a, int b, int c)
{
  int result = c - b; // 14
  int d = result << 31; // 0
  result = (result + d) >> 1; // 7
  d = result + b; // 7
  if (a < d)
  {
    c = d - 1;
    return 2 * func4(a, b, c, d);
  }
  if (a == d) 
  {
    return 0;
  }
  b = d + 1;
  return 2 * func4(a, b, c, d) + 1;
}
```

因此，最终的答案为`7 0`。

### 阶段五

```assembly
(gdb) disas phase_5
Dump of assembler code for function phase_5:
   0x0000000000401062 <+0>:	push   %rbx
   0x0000000000401063 <+1>:	sub    $0x20,%rsp
   0x0000000000401067 <+5>:	mov    %rdi,%rbx
   0x000000000040106a <+8>:	mov    %fs:0x28,%rax
   0x0000000000401073 <+17>:	mov    %rax,0x18(%rsp)
   0x0000000000401078 <+22>:	xor    %eax,%eax
   ---------------------------1----------------------------
   0x000000000040107a <+24>:	call   0x40131b <string_length>
   0x000000000040107f <+29>:	cmp    $0x6,%eax
   0x0000000000401082 <+32>:	je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:	call   0x40143a <explode_bomb>
   ---------------------------2----------------------------
   0x0000000000401089 <+39>:	jmp    0x4010d2 <phase_5+112>
   0x000000000040108b <+41>:	movzbl (%rbx,%rax,1),%ecx
   0x000000000040108f <+45>:	mov    %cl,(%rsp)
   0x0000000000401092 <+48>:	mov    (%rsp),%rdx
   0x0000000000401096 <+52>:	and    $0xf,%edx
   0x0000000000401099 <+55>:	movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 <+62>:	mov    %dl,0x10(%rsp,%rax,1)
   0x00000000004010a4 <+66>:	add    $0x1,%rax
   0x00000000004010a8 <+70>:	cmp    $0x6,%rax
   0x00000000004010ac <+74>:	jne    0x40108b <phase_5+41>
   ---------------------------3----------------------------
   0x00000000004010ae <+76>:	movb   $0x0,0x16(%rsp) ;末尾补\0，标志字符串结束
   0x00000000004010b3 <+81>:	mov    $0x40245e,%esi
   0x00000000004010b8 <+86>:	lea    0x10(%rsp),%rdi
   0x00000000004010bd <+91>:	call   0x401338 <strings_not_equal>
   0x00000000004010c2 <+96>:	test   %eax,%eax
   0x00000000004010c4 <+98>:	je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:	call   0x40143a <explode_bomb>
   ---------------------------4----------------------------
   0x00000000004010cb <+105>:	nopl   0x0(%rax,%rax,1)
   0x00000000004010d0 <+110>:	jmp    0x4010d9 <phase_5+119>
   0x00000000004010d2 <+112>:	mov    $0x0,%eax
   0x00000000004010d7 <+117>:	jmp    0x40108b <phase_5+41>
   0x00000000004010d9 <+119>:	mov    0x18(%rsp),%rax
   0x00000000004010de <+124>:	xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:	je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:	call   0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:	add    $0x20,%rsp
   0x00000000004010f2 <+144>:	pop    %rbx
   0x00000000004010f3 <+145>:	ret    
End of assembler dump.
```

* 根据phase_5<+24>~<+34>可知，输入字符串的长度必须等于6；
* phase_5<+41>~<+74>是一个循环，共执行六次：使用当前字符的低4位作为索引值（最大索引为15），从0x4024b0中取得对应的字符：

$$
\%rdx \leftarrow \%rdx + 0x4024b0
$$

而0x4024b0中的字符串前16位为`maduiersnfotvbyl`：

```assembly
(gdb) x/s 0x4024b0
0x4024b0 <array.3449>:	"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"
```

转换后的字符串在内存中的布局：

```c
%rsp + 0x10 | %rsp + 0x11 | %rsp + 0x12 | %rsp + 0x13 | %rsp + 0x14 | %rsp + 0x15 | %rsp + 0x16
```

* 根据phase_5<+81>~<+100>可知，经过转换后的字符串必须等于0x40245e中存储的字符串：

```assembly
(gdb) x/s 0x40245e
0x40245e:	"flyers"
```

因此，对于输入的6个字符，其低四位依次为：

| 字符 | 对应的索引（十进制） | 对应的索引（二进制） |
| :--: | :------------------: | :------------------: |
|  f   |          9           |         1001         |
|  l   |          15          |         1111         |
|  y   |          14          |         1110         |
|  e   |          5           |         0101         |
|  r   |          6           |         0110         |
|  s   |          7           |         0111         |

本题有非常多的可选答案，如**ionefg**、**IONEFG**等。

### 阶段六

```assembly
(gdb) disas phase_6
Dump of assembler code for function phase_6:
   0x00000000004010f4 <+0>:	push   %r14
   0x00000000004010f6 <+2>:	push   %r13
   0x00000000004010f8 <+4>:	push   %r12
   0x00000000004010fa <+6>:	push   %rbp
   0x00000000004010fb <+7>:	push   %rbx
   0x00000000004010fc <+8>:	sub    $0x50,%rsp
   ---------------------------1----------------------------
   0x0000000000401100 <+12>:	mov    %rsp,%r13
   0x0000000000401103 <+15>:	mov    %rsp,%rsi
   ; 1.输入六个数字，格式为%d %d %d %d %d %d
   0x0000000000401106 <+18>:	call   0x40145c <read_six_numbers>
   0x000000000040110b <+23>:	mov    %rsp,%r14
   0x000000000040110e <+26>:	mov    $0x0,%r12d
   ---------------------------2----------------------------
   ; 2.任一数字x - 1 <= 5，即0<= x <= 6
   0x0000000000401114 <+32>:	mov    %r13,%rbp
   0x0000000000401117 <+35>:	mov    0x0(%r13),%eax
   0x000000000040111b <+39>:	sub    $0x1,%eax
   0x000000000040111e <+42>:	cmp    $0x5,%eax
   0x0000000000401121 <+45>:	jbe    0x401128 <phase_6+52>
   0x0000000000401123 <+47>:	call   0x40143a <explode_bomb>
   ; 执行6次，然后跳出循环
   0x0000000000401128 <+52>:	add    $0x1,%r12d
   0x000000000040112c <+56>:	cmp    $0x6,%r12d
   0x0000000000401130 <+60>:	je     0x401153 <phase_6+95>
   -----------------------2.1------------------------
   ; 3.输入的六个数字不相等
   0x0000000000401132 <+62>:	mov    %r12d,%ebx
   0x0000000000401135 <+65>:	movslq %ebx,%rax
   0x0000000000401138 <+68>:	mov    (%rsp,%rax,4),%eax
   0x000000000040113b <+71>:	cmp    %eax,0x0(%rbp)
   0x000000000040113e <+74>:	jne    0x401145 <phase_6+81>
   0x0000000000401140 <+76>:	call   0x40143a <explode_bomb>
   0x0000000000401145 <+81>:	add    $0x1,%ebx
   0x0000000000401148 <+84>:	cmp    $0x5,%ebx
   0x000000000040114b <+87>:	jle    0x401135 <phase_6+65>
   -----------------------2.2------------------------
   0x000000000040114d <+89>:	add    $0x4,%r13
   0x0000000000401151 <+93>:	jmp    0x401114 <phase_6+32>
   ---------------------------3----------------------------
   0x0000000000401153 <+95>:	lea    0x18(%rsp),%rsi
   0x0000000000401158 <+100>:	mov    %r14,%rax
   ; 4.执行x = 7 - x
   0x000000000040115b <+103>:	mov    $0x7,%ecx
   0x0000000000401160 <+108>:	mov    %ecx,%edx
   0x0000000000401162 <+110>:	sub    (%rax),%edx
   0x0000000000401164 <+112>:	mov    %edx,(%rax)
   0x0000000000401166 <+114>:	add    $0x4,%rax
   0x000000000040116a <+118>:	cmp    %rsi,%rax
   0x000000000040116d <+121>:	jne    0x401160 <phase_6+108>
   -----------------------3.1------------------------
   0x000000000040116f <+123>:	mov    $0x0,%esi
   0x0000000000401174 <+128>:	jmp    0x401197 <phase_6+163>
   0x0000000000401176 <+130>:	mov    0x8(%rdx),%rdx
   0x000000000040117a <+134>:	add    $0x1,%eax
   0x000000000040117d <+137>:	cmp    %ecx,%eax
   0x000000000040117f <+139>:	jne    0x401176 <phase_6+130>
   0x0000000000401181 <+141>:	jmp    0x401188 <phase_6+148>
   0x0000000000401183 <+143>:	mov    $0x6032d0,%edx
   0x0000000000401188 <+148>:	mov    %rdx,0x20(%rsp,%rsi,2)
   0x000000000040118d <+153>:	add    $0x4,%rsi
   0x0000000000401191 <+157>:	cmp    $0x18,%rsi
   0x0000000000401195 <+161>:	je     0x4011ab <phase_6+183>
   0x0000000000401197 <+163>:	mov    (%rsp,%rsi,1),%ecx ;对应输入的6个数字
   0x000000000040119a <+166>:	cmp    $0x1,%ecx ;输入的6个数字>=1
   0x000000000040119d <+169>:	jle    0x401183 <phase_6+143>
   0x000000000040119f <+171>:	mov    $0x1,%eax
   0x00000000004011a4 <+176>:	mov    $0x6032d0,%edx
   0x00000000004011a9 <+181>:	jmp    0x401176 <phase_6+130>
   -----------------------3.2------------------------
   0x00000000004011ab <+183>:	mov    0x20(%rsp),%rbx
   0x00000000004011b0 <+188>:	lea    0x28(%rsp),%rax
   0x00000000004011b5 <+193>:	lea    0x50(%rsp),%rsi
   0x00000000004011ba <+198>:	mov    %rbx,%rcx
   0x00000000004011bd <+201>:	mov    (%rax),%rdx
   0x00000000004011c0 <+204>:	mov    %rdx,0x8(%rcx)
   0x00000000004011c4 <+208>:	add    $0x8,%rax
   0x00000000004011c8 <+212>:	cmp    %rsi,%rax
   0x00000000004011cb <+215>:	je     0x4011d2 <phase_6+222>
   0x00000000004011cd <+217>:	mov    %rdx,%rcx
   0x00000000004011d0 <+220>:	jmp    0x4011bd <phase_6+201>
   ---------------------------4----------------------------
   0x00000000004011d2 <+222>:	movq   $0x0,0x8(%rdx)
   0x00000000004011da <+230>:	mov    $0x5,%ebp
   0x00000000004011df <+235>:	mov    0x8(%rbx),%rax
   0x00000000004011e3 <+239>:	mov    (%rax),%eax
   0x00000000004011e5 <+241>:	cmp    %eax,(%rbx)
   0x00000000004011e7 <+243>:	jge    0x4011ee <phase_6+250>
   0x00000000004011e9 <+245>:	call   0x40143a <explode_bomb>
   0x00000000004011ee <+250>:	mov    0x8(%rbx),%rbx
   0x00000000004011f2 <+254>:	sub    $0x1,%ebp
   0x00000000004011f5 <+257>:	jne    0x4011df <phase_6+235>
   ---------------------------5----------------------------
   0x00000000004011f7 <+259>:	add    $0x50,%rsp
   0x00000000004011fb <+263>:	pop    %rbx
   0x00000000004011fc <+264>:	pop    %rbp
   0x00000000004011fd <+265>:	pop    %r12
   0x00000000004011ff <+267>:	pop    %r13
   0x0000000000401201 <+269>:	pop    %r14
   0x0000000000401203 <+271>:	ret    
End of assembler dump.
```

* 根据<+18>可知，需要输入六个数字，格式为`%d %d %d %d %d %d`；
* 根据<+32>~<+93>可知，六个数字的内存布局为：

```c
%rsp | %rsp + 0x4 | %rsp + 0x8 | %rsp + 0xc | %rsp + 0x10 | %rsp + 0x14 |
```

* 根据<+35>~<+56>可知，输入的六个数字 - 1 <= 5，即0 <= 六个数字 <= 6；

* 根据<+62>~<+87>可知，任何一个数字不能和其他五个数字相等；

* 根据<+103>~<+112>可知，对六个数字依次执行如下操作：

$$
x = 7 - x
$$

* 根据<+123>~<+181>可以得到：

```c
%rsi = 0
%edx = 0x6032d0
// 当%rsi的值等于24（0x18），即执行6次后，循环结束
while %rsi != 0x18 do:
    %rsp + 2 × %rsi + 0x20 = %edx;
    // 每次增加4
    %rsi = %rsi + 0x4;
    // 对应输入的6个数字：%rsp, %rsp + 4, ..., %rsp + 0x14
    %ecx = %rsp + %rsi;
    // %ecx >= 1。因此，1 <= 输入的数字 <= 6
    ...
    // 当循环结束时，%rdx中存储了以输入数字为编号的节点地址
    while %ecx != %eax do:
        %rdx = %rdx->next;
        %eax++;
    end while
end while
```

将从0x6032d0开始的六个地址存入`%rsp+0x20 ~ %rsp+0x48`中，内存布局为：

```assembly
| %rsp + 0x20 | %rsp + 0x28 | %rsp + 0x30 | %rsp + 0x38 | %rsp + 0x40 | %rsp + 0x48 |
```

从地址0x6032d0开始，六个节点的信息为：

```c
// 每个节点占8个字节，六个节点共占48个字节，即24w
(gdb) x/24wd 0x6032d0
0x6032d0 <node1>:	332	1	6304480	0
0x6032e0 <node2>:	168	2	6304496	0
0x6032f0 <node3>:	924	3	6304512	0
0x603300 <node4>:	691	4	6304528	0
0x603310 <node5>:	477	5	6304544	0
0x603320 <node6>:	443	6	0	0
```

节点定义如下：

```c
struct node
{
    int value;
    int no;
    struct node * next;
}
```

* 根据<+183>~<+220>可知，`%rsp+0x20 ~ %rsp+0x48`被依次链接起来，形成一个链表；
* 根据<+235>~<+257>可知，链表中节点的值必须按照递减排列：

| 节点值 | 节点编号 | 输入的数字 = 7 - 节点编号 |
| :----: | :------: | :-----------------------: |
|  924   |    3     |             4             |
|  691   |    4     |             3             |
|  477   |    5     |             2             |
|  443   |    6     |             1             |
|  332   |    1     |             6             |
|  168   |    2     |             5             |

因此，输入的字符串为`4 3 2 1 6 5`。