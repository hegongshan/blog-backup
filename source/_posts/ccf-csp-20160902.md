---
title: CCF CSP 201609-2.火车购票
date: 2019-07-27 21:27:36
tags: ccf csp
categories: ccf csp
---

**问题描述**

　　请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。
　　假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。
　　购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。
　　假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。

<!--more-->

**输入格式**

　　输入的第一行包含一个整数*n*，表示购票指令的数量。
　　第二行包含*n*个整数，每个整数*p*在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。

**输出格式**

　　输出*n*行，每行对应一条指令的处理结果。
　　对于购票指令*p*，输出*p*张车票的编号，按从小到大排序。

**样例输入**

4
2 5 4 2

**样例输出**

1 2
6 7 8 9 10
11 12 13 14
3 4

**样例说明**

　　1) 购2张票，得到座位1、2。
　　2) 购5张票，得到座位6至10。
　　3) 购4张票，得到座位11至14。
　　4) 购2张票，得到座位3、4。

**评测用例规模与约定**

　　对于所有评测用例，1 ≤ *n* ≤ 100，所有购票数量之和不超过100。

<hr>

**分析：**

用int型数组seat表示各排剩下的座位数，下标从0开始。

购票时有以下两种情况：

1.第*i*排存在p个相邻的空座位。此时，找到空座位的起始编号`start =i * 5 + 5 - seat[i] + 1 `，依次输出p个座位的编号即可；

2.车厢中不存在相邻的p个空座位。此时，从小到大，依次遍历各排，寻找空座位，输出p个座位的编号（若存在p个空座位）。

```c++
#include <cstdio>

int main() {
	int n, p;
	scanf("%d", &n);
	// 存储每排剩余的座位数
	int seat[20];
	for (int i = 0; i < 20; i++) {
		seat[i] = 5;
	}

	while (n--) {
		scanf("%d", &p);

		int i = 0;
		while (i < 20 && seat[i] < p) {
			i++;
		}
		// 若第i排存在相邻的p个空座位
		if (i < 20) {
 			// 起始座位号
			int start = i * 5 + 5 - seat[i] + 1;
			seat[i] -= p;
			for (int i = 0; i < p; i++) {
				printf("%d", start + i);
				if (i < p - 1) {
					printf(" ");
				}
			}
		} else {
			// 若不存在相邻的p个空座位，则寻找编号最小的p个座位
			for (i = 0; i < 20 && p > 0; i++) {
				if (seat[i] == 0) {
					continue;
				}

				// 起始座位号
				int start = i * 5 + 5 - seat[i] + 1;
				int j = 0;
				while (j < seat[i] && j < p) {
					printf("%d", start + j);
					if (p > 0) {
						printf(" ");
					}
					j++;
				}
				p -= j;
				seat[i] -= j;
			}
		}
		printf("\n");
	}
	return 0;
}
```

