---
title: CCF CSP 201812-2.小明放学
date: 2019-07-19 15:11:35
tags: ccf csp
categories: ccf csp
---

**题目背景**

　　汉东省政法大学附属中学所在的光明区最近实施了名为“智慧光明”的智慧城市项目。具体到交通领域，通过“智慧光明”终端，可以看到光明区所有红绿灯此时此刻的状态。小明的学校也安装了“智慧光明”终端，小明想利用这个终端给出的信息，估算自己放学回到家的时间。

<!--more-->

**问题描述**

　　一次放学的时候，小明已经规划好了自己回家的路线，并且能够预测经过各个路段的时间。同时，小明通过学校里安装的“智慧光明”终端，看到了**出发时刻**路上经过的所有红绿灯的指示状态。请帮忙计算小明此次回家所需要的时间。

**输入格式**

　　输入的第一行包含空格分隔的三个正整数 r、y、g，表示红绿灯的设置。这三个数均不超过 10^6。
　　输入的第二行包含一个正整数 n，表示小明总共经过的道路段数和路过的红绿灯数目。
　　接下来的 n 行，每行包含空格分隔的两个整数 k、t。k=0 表示经过了一段道路，将会耗时 t 秒，此处 t 不超过 10^6；k=1、2、3 时，分别表示**出发时刻**，此处的红绿灯状态是红灯、黄灯、绿灯，且倒计时显示牌上显示的数字是 t，此处 t 分别不会超过 r、y、g。

**输出格式**

　　输出一个数字，表示此次小明放学回家所用的时间。

**样例输入**

30 3 30
8
0 10
1 5
0 11
2 2
0 6
0 3
3 10
0 3

**样例输出**

46

**样例说明**

　　小明先经过第一段路，用时 10 秒。第一盏红绿灯出发时是红灯，还剩 5 秒；小明到达路口时，这个红绿灯已经变为绿灯，不用等待直接通过。接下来经过第二段路，用时 11 秒。第二盏红绿灯出发时是黄灯，还剩两秒；小明到达路口时，这个红绿灯已经变为红灯，还剩 11 秒。接下来经过第三、第四段路，用时 9 秒。第三盏红绿灯出发时是绿灯，还剩 10 秒；小明到达路口时，这个红绿灯已经变为红灯，还剩两秒。接下来经过最后一段路，用时 3 秒。共计 10+11+11+9+2+3 = 46 秒。

**评测用例规模与约定**

　　有些测试点具有特殊的性质：
　　* 前 2 个测试点中不存在任何信号灯。
　　测试点的输入数据规模：
　　* 前 6 个测试点保证 n ≤ 10^3。
　　* 所有测试点保证 n ≤ 10^5。

<hr>

**分析：**

用time表示回家所用的时间。

遇到道路，即`k==0`，则将t加到time上；

遇到红绿灯，则通过取余操作，计算当前交通信号灯的状态：`rear = (time - t) % (r + g + y);`，其中rear表示某个信号灯已经用掉的时间，

若为红灯，则将红灯剩余的时间加到time上；

若为黄灯，则将**黄灯剩余的时间以及一个红灯的时间**加到time上。

**本题需要注意的地方：**

第一，交通灯的变换顺序为：**红->绿->黄->红**。每次遇到黄灯，需要多等待一个红灯的时间。

第二， n ≤ 10^5，t ≤ 10^6，max(time)=n*t = 10^11。因此，time需要声明为long long类型。

```c++
#include <cstdio>

int main() {
	int r, y, g;
	scanf("%d %d %d", &r, &y, &g);

	int n, k, t;
	scanf("%d", &n);
	long long time = 0;
	for (int i = 0; i < n; i++) {
		scanf("%d %d", &k, &t);
		if (k == 0) {
			time += t;
		} else if (k == 1) { // 红灯
			if (t > time) {
				time = t;
			} else {
  				// rear表示某个信号灯已经用掉的时间
				int rear = (time - t) % (g + y + r);
				if (rear > g && rear <= g + y) { // 当前为黄灯
					time += g + y - rear + r;
				} else if (rear > g + y) { // 红灯
					time += g + y + r - rear;
				}
			}
		} else if (k == 2) { // 黄灯
			if (t > time) {
				time = t + r;
			} else {
				int rear = (time - t) % (r + g + y);
				if (rear <= r) { // 红灯
					time += r - rear;
				} else if (rear > r + g) { //黄灯
					time += r + g + y - rear + r;
				}
			}
		} else { // 绿灯
			if (t < time) {
				int rear = (time - t) % (y + r + g);
				//黄灯
				if (rear <= y) {
					time += y - rear + r;
				} else if (rear <= y + r) {
					time += y + r - rear;
				}
			}
		}
	}
	printf("%lld\n", time);
	return 0;
}
```

若得分为20，则表示没有考虑到黄灯后是红灯；

若得分为60，则表示没有考虑到数据的取值范围，time<=10^11。