---
title: CCF CSP 201512-2.消除类游戏
date: 2019-08-01 14:58:09
tags: ccf csp
categories: ccf csp
---

**问题描述**

　　消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有*n*行*m*列的游戏棋盘上进行，棋盘的每一行每一列的方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地方的棋子将同时被消除。
　　现在给你一个*n*行*m*列的棋盘，棋盘中的每一个方格上有一个棋子，请给出经过一次消除后的棋盘。
　　请注意：一个棋子可能在某一行和某一列同时被消除。

<!--more-->

**输入格式**

　　输入的第一行包含两个整数*n*, *m*，用空格分隔，分别表示棋盘的行数和列数。
　　接下来*n*行，每行*m*个整数，用空格分隔，分别表示每一个方格中的棋子的颜色。颜色使用1至9编号。

**输出格式**

　　输出*n*行，每行*m*个整数，相邻的整数之间使用一个空格分隔，表示经过一次消除后的棋盘。如果一个方格中的棋子被消除，则对应的方格输出0，否则输出棋子的颜色编号。

**样例输入**

4 5
2 2 3 1 2
3 4 5 1 4
2 3 2 1 3
2 2 2 4 4

**样例输出**

2 2 3 0 2
3 4 5 0 4
2 3 2 0 3
0 0 0 4 4

**样例说明**

　　棋盘中第4列的1和第4行的2可以被消除，其他的方格中的棋子均保留。

**样例输入**

4 5
2 2 3 1 2
3 1 1 1 1
2 3 2 1 3
2 2 3 3 3

**样例输出**

2 2 3 0 2
3 0 0 0 0
2 3 2 0 3
2 2 0 0 0

**样例说明**

　　棋盘中所有的1以及最后一行的3可以被同时消除，其他的方格中的棋子均保留。

**评测用例规模与约定**

　　所有的评测用例满足：1 ≤ *n*, *m* ≤ 30。

<hr>

**分析：**

添加一个nxm的标记数组mark，所有元素的值均初始化为1。

先从行的角度考虑待消除的棋子，再从列的角度考虑待消除的棋子，并将待消除的方格标记为0。

最后，遍历棋盘，若`mark[i][j] == 1`，则输出原棋盘上的棋子；否则，输出0，表示该棋子已被消除。

```c++
#include <cstdio>

int main() {
	int n, m;
	scanf("%d %d", &n, &m);

	int data[n][m], mark[n][m];
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			scanf("%d", &data[i][j]);
			mark[i][j] = 1;
		}
	}

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m - 2; j++) {
			if (data[i][j] == data[i][j + 1]
					&& data[i][j + 1] == data[i][j + 2]) {
				mark[i][j] = mark[i][j + 1] = mark[i][j + 2] = 0;
			}
		}
	}

	for (int i = 0; i < n - 2; i++) {
		for (int j = 0; j < m; j++) {
			if (data[i][j] == data[i + 1][j]
					&& data[i + 1][j] == data[i + 2][j]) {
				mark[i][j] = mark[i + 1][j] = mark[i + 2][j] = 0;
			}
		}
	}

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (j > 0) {
				printf(" ");
			}
			if (mark[i][j] == 1) {
				printf("%d", data[i][j]);
			} else {
				printf("0");
			}
		}
		printf("\n");
	}

	return 0;
}
```

