---
title: CCF CSP 201703-4.地铁修建
date: 2019-08-06 21:46:13
tags: ccf csp
categories: ccf csp
---

**问题描述**

　　A市有n个交通枢纽，其中1号和n号非常重要，为了加强运输能力，A市决定在1号到n号枢纽间修建一条地铁。
　　地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有m段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，没有隧道两端连接着同一个交通枢纽。
　　现在有n家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。所有公司同时开始施工。
　　作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地铁最少需要多少天。

<!--more-->

**输入格式**

　　输入的第一行包含两个整数*n*, *m*，用一个空格分隔，分别表示交通枢纽的数量和候选隧道的数量。
　　第2行到第*m*+1行，每行包含三个整数*a*, *b*, *c*，表示枢纽*a*和枢纽*b*之间可以修建一条隧道，需要的时间为*c*天。

**输出格式**

　　输出一个整数，修建整条地铁线路最少需要的天数。

**样例输入**

6 6
1 2 4
2 3 4
3 6 7
1 4 2
4 5 5
5 6 6

**样例输出**

6

**样例说明**

　　可以修建的线路有两种。
　　第一种经过的枢纽依次为1, 2, 3, 6，所需要的时间分别是4, 4, 7，则整条地铁线需要7天修完；
　　第二种经过的枢纽依次为1, 4, 5, 6，所需要的时间分别是2, 5, 6，则整条地铁线需要6天修完。
　　第二种方案所用的天数更少。

**评测用例规模与约定**

　　对于20%的评测用例，1 ≤ *n* ≤ 10，1 ≤ *m* ≤ 20；
　　对于40%的评测用例，1 ≤ *n* ≤ 100，1 ≤ *m* ≤ 1000；
　　对于60%的评测用例，1 ≤ *n* ≤ 1000，1 ≤ *m* ≤ 10000，1 ≤ *c* ≤ 1000；
　　对于80%的评测用例，1 ≤ *n* ≤ 10000，1 ≤ *m* ≤ 100000；
　　对于100%的评测用例，1 ≤ *n* ≤ 100000，1 ≤ *m* ≤ 200000，1 ≤ *a*, *b* ≤ *n*，1 ≤ *c* ≤ 1000000。

　　所有评测用例保证在所有候选隧道都修通时1号枢纽可以通过隧道到达其他所有枢纽。

<hr>

**分析：**

“所有公司同时开始施工。”因此，本题可认为是**求最小生成树中的最大边权**。

可以采用**kruskal算法**求解。当1和n连通时，结束kruskal算法。

```c++
#include <cstdio>
#include <algorithm>
using namespace std;

typedef struct Node {
	// 边的两个端点
	int u, v;
	// 需要的时间
	int w;
} Edge;

Edge edge[200000];
// 并查集
int usf[100001];

bool cmp(Edge a, Edge b) {
	return a.w < b.w;
}

int find(int x) {
	int a = x;
	while (x != usf[x]) {
		x = usf[x];
	}
	// 路径压缩
	while (a != usf[a]) {
		int z = a;
		a = usf[a];
		usf[z] = x;
	}
	return x;
}

int kruskal(int n, int m) {
	for (int i = 1; i <= n; i++) {
		usf[i] = i;
	}
	sort(edge, edge + m, cmp);
	int result = 0;
	for (int i = 0; i < m; i++) {
		int u = find(edge[i].u);
		int v = find(edge[i].v);
		if (u != v) {
			usf[u] = v;
			// 最小生成树中的最大边权
			result = max(result, edge[i].w);
		}
		// 当1和n连通时，结束循环
		if (find(1) == find(n)) {
			break;
		}
	}
	return result;
}

int main() {
	int n, m;
	scanf("%d %d", &n, &m);
	for (int i = 0; i < m; i++) {
		scanf("%d %d %d", &edge[i].u, &edge[i].v, &edge[i].w);
	}

	int result = kruskal(n, m);
	printf("%d\n", result);
	return 0;
}
```

