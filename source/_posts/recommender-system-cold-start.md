---
title: 《推荐系统实践》4.推荐系统冷启动问题
date: 2019-03-14 11:43:54
tags: recommender system
categories: recommender system
mathjax: true
---

推荐系统需要根据用户的历史行为和兴趣预测用户未来的行为和兴趣，因此大量的用户行为数据就成为推荐系统的重要组成部分和先决条件。 

如何在没有大量用户数据的情况下设计个性化推荐系统并且让用户对推荐结果满意从而愿意使用推荐系统，就是**冷启动问题（cold start）**。

<!--more-->

### 冷启动分类

* 用户冷启动：如何给新用户做个性化推荐。
* 物品冷启动：如何将新的物品推荐给可能对它感兴趣的用户。
* 系统冷启动：如何在一个新开发的网站上（还没有用户，也没有用户行为，只有一些物品的信息）设计个性化推荐系统，从而在网站刚发布时就让用户体验到个性化推荐服务。

### 利用用户注册信息

1.利用用户的注册信息可以很好地解决注册用户的冷启动问题。

当新用户刚注册时，我们不知道他喜欢什么物品，于是只能给他推荐一些热门的商品。但如果我们知道她是一位女性，那么可以给她推荐女性都喜欢的热门商品。虽然这种个性化的粒度很粗，因为所有刚注册的女性看到的都是同样的结果，但相对于不区分男女的方式，这种推荐的精度已经大大提高了。

2.用户的注册信息分3种：

* 人口统计学信息：包括用户的年龄、性别、职业、民族、学历和居住地。
* 用户兴趣的描述：有一些网站会让用户用文字描述他们的兴趣。
* 从其他网站导入的用户站外行为数据：比如用户通过豆瓣、新浪微博的账号登录，就可以在得到用户同意的情况下获取用户在豆瓣或者新浪微博的一些行为数据和社交网络数据。

3.基于注册信息的个性化推荐流程基本如下:

(1) 获取用户的注册信息;

(2) 根据用户的注册信息对用户分类;

(3) 给用户推荐他所属分类中用户喜欢的物品。

4.基于用户注册信息的推荐算法的**核心问题**是计算每种特征的用户喜欢的物品。也就是说，对于

每种特征f，计算具有这种特征的用户对各个物品的喜好程度preference(f, i)。

preference( f ,i ) 可以简单地定义为**物品i在具有特征f的用户中的热门程度**：
$$
preference(f,i) = |N(i) \cap U(f)| \tag{1}
$$
其中，N(i)是喜欢物品i的用户集合，U(f)是具有特征f的用户集合。

上面这种定义可以比较准确地预测具有某种特征的用户是否喜欢某个物品。但是，在这种定义下，往往热门的物品会在各种特征的用户中都具有比较高的权重。 

因此，我们可以将 preference(f,i) 定义为**喜欢物品i的用户中具有特征f的比例**:
$$
preference(f,i) = \frac{|N(i) \cap U(f)|}{|N(i)|+ \alpha} \tag{2}
$$
这里分母中使用参数$\alpha​$的目的是**解决数据稀疏问题**。比如有一个物品只被1个用户喜欢过，而这个用户刚好就有特征f，那么就有preference(f,i)=1 。但是，这种情况并没有统计意义，因此我们为分母加上一个比较大的数，可以避免这样的物品产生比较大的权重。

### 选择合适的物品启动用户的兴趣

解决用户冷启动问题的另一个方法是在新用户第一次访问推荐系统时，不立即给用户展示推荐结果，而是给用户提供一些物品，让用户反馈他们对这些物品的兴趣，然后根据用户反馈给提供个性化推荐。

该方法的**首要问题**是**如何选择物品让用户进行反馈**。

一般来说，能够用来启动用户兴趣的物品需要具有以下特点:

* 比较热门

如果要让用户对一个物品进行反馈，前提是用户知道这个物品是什么东西。

以电影为例，如果一开始让用户进行反馈的电影都很冷门，而用户不知道这些电影的情节和内容，也就无法对它们做出准确的反馈。

* 具有代表性和区分性：

启动用户兴趣的物品不能是大众化或老少咸宜的，因为这样的物品对用户的兴趣没有区分性。

* 启动物品集合需要有多样性：

在冷启动时，我们不知道用户的兴趣，而用户兴趣的可能性非常多，为了匹配多样的兴趣，我们需要提供具有很高覆盖率的启动物品集合，这些物品能覆盖几乎所有主流的用户兴趣。

### 利用物品的内容信息

对于基于物品的协同过滤算法（以下简称ItemCF）算法来说，物品冷启动是一个严重的问题了。因为ItemCF算法的原理是给用户推荐和他之前喜欢的物品相似的物品。ItemCF算法会每隔一段时间利用用户行为计算物品相似度表(一般一天计算一次)，在线服务时ItemCF算法会将之前计算好的物品相关度矩阵放在内存中。因此，当新物品加入时，内存中的物品相关表中不会存在这个物品，从而ItemCF算法无法推荐新的物品。

解决这一问题的办法是**频繁更新物品相似度表**，但基于用户行为计算物品相似度是非常
耗时的事情，主要原因是用户行为日志非常庞大。而且，新物品如果不展示给用户，用户就无法
对它产生行为，通过行为日志计算是计算不出包含新物品的相关矩阵的。为此，我们只能**利用物品的内容信息计算物品相关表**，并且频繁地更新相关表(比如半小时计算一次)。

一般来说，物品的内容可以通过向量空间模型表示，该模型会将物品表示成一个关键词向量。

从文本生成关键词向量的主要步骤：

（1）对于中文，首先要对文本进行分词，将字流变成词流；

（2）然后从词流中检测出命名实体(如人名、地名、组织名等)，这些实体和一些其他重要的词将组成关键词集合；

（3）最后对关键词进行排名，计算每个关键词的权重，从而生成关键词向量。

对物品d，它的内容表示成一个关键词向量如下:
$$
d_i = {\left((e_1, w_1),(e_2, w_2),\dots \right)} \tag{3}
$$
其中，$e_i​$是关键词，$w_i​$是关键词对应的权重。

在给定物品内容的关键词向量后，物品的内容相似度可以通过向量之间的余弦相似度计算
$$
w_{ij} = \frac{d_i \cdot d_j}{\sqrt{||d_i||\times||d_j||}} \tag{4}
$$
得到物品的相似度之后，可以利用ItemCF算法的思想，给用户推荐和他历史上喜欢的物品内容相似的物品。